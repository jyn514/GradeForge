#!/usr/bin/env python3

'''Autogenerated SQL commands for creating an SQL database
TODO:
- have James redo schema
- add location table (all info is available in course['location'])
- make insertion NOT dependent on order dictionaries were created
- make bookstore_link a property of course instead of section
- compare section attribute to course attribute and remove if same
- ask brady if we care about registration start
'''

import sqlite3

# dictionaries are insertion ordered; see https://stackoverflow.com/q/39980323
# do not change order without also modifying parse.py
# (this happened because I was lazy in the main portion) - JN
TABLES = {'class': ["course_link tinytext",
                    "title tinytext",
                    "department char(4)",
                    "code varchar(4)",
                    "description text",
                    "credits tinyint(1)",
                    "attributes text",
                    "level tinytext",
                    "type tinytext",
                    "all_sections tinytext"],
          'department': ["abbr char(4)",
                         "title tinytext"],
          'instructor': ["name tinytext",
                         "email tinytext"],
          'semester': ["id char(6)",
                       "startDate date",
                       "endDate date",
                       'registrationStart data',
                       "registrationEnd date"],
          'location': ["uid smallint",
                       "building tinytext",
                       "room smallint"],
          'section': ["section_link",
                      "uid tinyint(5)",
                      "section tinytext",
                      "department char(4)",
                      "code varchar(4)",
                      "semester char(6)",
                      "attributes tinytext",
                      "campus tinytext",
                      'type tinytext',
                      'method tinytext',
                      'catalog_link',
                      'bookstore_link',
                      "syllabus tinytext",
                      "days varchar(7)",
                      "location smallint",
                      "startTime time",
                      "endTime time",
                      "instructor tinytext",  # this is by email, not name (since email is unique)
                      "finalExam dateTime"]
                     # always out of date; requires parsing different page
                     #"capacity tinyint", "remaining tinyint"
         }

def create_sql(DEPARTMENTS, CLASSES, INSTRUCTORS, SEMESTERS, SECTIONS, database='../classes.sql'):
    DATABASE = sqlite3.connect(database)
    CURSOR = DATABASE.cursor()

    CURSOR.executescript(''.join('CREATE TABLE %s(%s);' % (key, ', '.join(value))
                                 for key, value in TABLES.items()))

    CURSOR.executemany('INSERT INTO class VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                       (tuple(c.values()) for c in CLASSES))

    CURSOR.executemany('INSERT INTO department VALUES (?, ?)',
                       tuple(DEPARTMENTS.items()))
    CURSOR.executemany('INSERT INTO instructor VALUES (?, ?)',
                       tuple(INSTRUCTORS.items()))

    CURSOR.executemany('INSERT INTO semester VALUES (?, ?, ?, ?, ?)', SEMESTERS)

    CURSOR.executemany('INSERT INTO section VALUES (%s)' %
                       ', '.join('?' * len(TABLES['section'])), # didn't feel like typing
                       # final exam not done yet
                       (tuple(s.values()) + ('None',) for s in SECTIONS))
    DATABASE.commit()
    DATABASE.close()


def limited_query(database='classes.sql', table='section', columns='*', **filters):
    '''NOTE: Does NOT validate input, that is the responsibility of calling code.
    Fails noisily if args are incorrect. Example: query_sql.py --department CSCE CSCI'''
    DATABASE = sqlite3.connect(database)
    # ex: subject IN ('CSCE', 'CSCI') AND CRN IN (12345, 12346)
    query_filter = ' AND '.join([key + ' IN (%s)' % str(value)[1:-1].replace("'", '"')
                                 for key, value in filters.items()])
    command = 'SELECT %s FROM %s%s;' % (', '.join(columns), table,
                                        ' WHERE ' + query_filter if query_filter != '' else '')
    if DEBUG:
        print(command, filters)
    stdout = DATABASE.execute(command).fetchall()
    DATABASE.close()
    return stdout


def query(query, database='classes.sql'):
    '''Return the result of an sql query exactly as if it had been passed to the sqlite3 binary'''
    return '\n'.join('|'.join(str(s) for s in t)
                     for t in sqlite3.connect(database).execute(query).fetchall())
